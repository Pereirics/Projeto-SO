\documentclass{report}
\usepackage{graphicx} % Required for inserting images

\title{SO}
\author{Miguel Pereira}
\date{May 2023}

\begin{document}

\maketitle

\section{Introduction}

\section{Funcionalidades Básicas}

\subsection{"execute -u"}

Em geral,

Para então prosseguirmos com a execução do programa em questão, definiu-se uma função execute onde se processa a inicialização com um fork (para permitir a execução sem uma terminação prévia do programa), onde o comando procede com os respectivos argumentos. Foram também escritas mensagens de erro caso aconteçam durante o correr do código, desde a impossibilidade de criação de um processo filho à execução através do execvp.

Os argumentos em questão foram separados por uma função tokenizer e durante todo o processamento de dados do código será maioritariamente suportado por uma struct prog. Seguem-se então breves explicações sobre a construção e funcionamento destes.

\subsubsection{Tokenizer}

Derivado da criação da funcionalidade “execute -u”, onde será necessário analisar o conteúdo da string fornecida pelo utilizador ao cliente, surgiu a necessidade da criação de um sistema auxiliar que nos permita dividir esta em seus vários componentes (cujo parâmetro de divisão seja o caracter espaço).

Com isto em mente, recorreu-se a uma função tokenizer, aonde se dá a separação do input introduzido pelo utilizador em tokens de formato string (que posteriormente serão armazenados array), o que então possibilita o uso do conteúdo do programa em si – o seu comando e respetivos argumentos – em outras funcionalidades do projeto.

\subsubsection{Struct prog}

Para a transição de informação entre o cliente e o servidor de um programa (entre os pipes e, por continuidade, as pipelines), procedeu-se a criação de uma struct que armazena todos os dados aos quais pretendemos trabalhar com – desde o comando, argumentos associados, o tempo de iniciação do processo e respetivo tempo de execução. Deste modo, haverá menos perda de informação e esta estará organizada de uma maneira mas sucinta.

\subsubsection{Execute: Cliente}

A funcionalidade core do projeto, o execute, procede com a cálculo de um processo filho que estará conectado a um pipe que servirá para futuro intercambio de informação com os processos a correr. Prossegue-se então para a execução os comandos que serão introduzidos pelo utilizador seguido da função.

Com a função gettimeofday, procedemos a atribuição do tempo inicial ao qual um programa começa a executar e passa-se essa informação através de uma struct previamente criada a fim de guardar o PID (do filho em causa) e esse mesmo tempo para o processo pai através de um pipe anónimo e ao servidor atravès de um FIFO. Neste também será enviada o nome do comando que foi executado com sucesso.

Assim que o processo filho termina a sua execução, o processo pai (que estava em modo WAIT, ou seja, em modo espera) chama também a função gettimeofday para obter o tempo de término e com a informação recebida do filho, este calcula a diferença entre ambos – isto é, o tempo que o programa demorou a executar. Essa duração em milissegundos juntamente com o PID do processo filho que acabou de concluir serão então enviados para o servidor por FIFO.

Durante o correr das introduções deste pedaço de código, o utilizador é informado do PID do programa que está a correr e no final, o tempo de exucução do mesmo. O utilizador também é informado de vários erros que posso acontecer durante a execução.

\subsubsection{Execute: Servidor}

Para simplificar o processamento de informação dos vários programas que estão a execução, criou-se um array store que vai armazenar em cada índice struct prog. Tendo este array, inicializamos a leitura do PID enviado e vai consultar se este já existe dentro de algum índice do store. Se encontrado, quer dizer que o programa em questão já terminou; se não encontrar, armanazena-o.

\subsection{"status"}

\end{document}


